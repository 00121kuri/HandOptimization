using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using static UnityEngine.GraphicsBuffer;

public class SimpleIK_CCD : MonoBehaviour
{
    public int totalIterations = 10;
    public float threshold = 0.01f;
    public Transform joint1;
    public Transform joint2;
    public Transform joint3;
    public Transform joint4; // This is the end-effector
    public Transform target;

    private void LateUpdate()
    {
        int iterations = 0;

        for (int i = 0; i < totalIterations; i++)
        {
            // Update each joint to face the end-effector towards the target
            RotateTowardsTarget(joint1, joint4.position);
            RotateTowardsTarget(joint2, joint4.position);
            RotateTowardsTarget(joint3, joint4.position);

            // Increase the iteration counter
            iterations++;

            // If the distance between the end-effector (joint4) and target is less than the threshold, break
            if (Vector3.Distance(joint4.position, target.position) < threshold)
                break;
        }

        // Log the number of iterations
        Debug.Log("Total specified iterations: " + totalIterations + ", Iterations performed: " + iterations);

        // Update the end-effector to face the target directly
        joint4.LookAt(target.position);
    }

    private void RotateTowardsTarget(Transform joint, Vector3 endEffectorPosition)
    {
        // 1. ???????W????x?N?g???itoTarget?j???????G???h?G?t?F?N?^????x?N?g???itoEndEffector?j???v?Z??????B
        // ??????x?N?g????A??????p?x???v?Z????????b???????B
        Vector3 toTarget = (target.position - joint.position).normalized;
        Vector3 toEndEffector = (endEffectorPosition - joint.position).normalized;

        // 2. Vector3.SignedAngle???g????AtoEndEffector??toTarget????p?x???v?Z??????B?????????????????]?????????m?ç·??????????B
        // ????p?x??AtoEndEffector????toTarget????Z??p?x?????????B
        float angle = Vector3.SignedAngle(toEndEffector, toTarget, Vector3.Cross(toEndEffector, toTarget));

        // 3. ????????p?x??????]????????B??]?????AtoEndEffector??toTarget??O??????????????B
        // ?O?ƒÏiCross product?j??A????x?N?g???????????O????x?N?g?????v?Z??????B????????]????????????B
        joint.rotation = Quaternion.AngleAxis(angle, Vector3.Cross(toEndEffector, toTarget)) * joint.rotation;
    }
}
